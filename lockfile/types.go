package lockfile

import (
	"encoding/json"
)

// CurrentVersion is the lockfile format version this package targets.
// This corresponds to Bazel 9.0.0 lockfile format.
// See version.go for the complete Bazel-to-lockfile version mapping.
const CurrentVersion = 26

// Lockfile represents a MODULE.bazel.lock file.
// This matches Bazel's BazelLockFileValue structure.
type Lockfile struct {
	// Version is the lockfile format version.
	Version int `json:"lockFileVersion"`

	// RegistryFileHashes maps registry URLs to their content hashes.
	// Keys are full URLs like "https://bcr.bazel.build/modules/foo/1.0/MODULE.bazel".
	// Values are SHA256 hashes of the file contents.
	RegistryFileHashes map[string]string `json:"registryFileHashes"`

	// SelectedYankedVersions maps ModuleKey strings to yank reasons.
	// These are yanked versions that were explicitly allowed.
	SelectedYankedVersions map[string]string `json:"selectedYankedVersions"`

	// ModuleExtensions contains cached results of module extension evaluations.
	// Keys are extension identifiers like "@@rules_go+//go:extensions.bzl%go_sdk".
	ModuleExtensions map[string]ModuleExtensionEntry `json:"moduleExtensions"`

	// Facts contains additional facts about module extensions.
	Facts map[string]json.RawMessage `json:"facts"`
}

// ModuleExtensionEntry contains evaluation results for a module extension.
// The map key is the evaluation factors (OS, arch, etc.).
type ModuleExtensionEntry map[string]ModuleExtensionData

// ModuleExtensionData contains the cached data for a module extension evaluation.
type ModuleExtensionData struct {
	// General contains the main extension evaluation results.
	General *ExtensionGeneral `json:"general,omitempty"`

	// RecordedInputs lists inputs that were read during evaluation.
	RecordedInputs []string `json:"recordedInputs,omitempty"`
}

// ExtensionGeneral contains general extension evaluation data.
type ExtensionGeneral struct {
	// BzlTransitiveDigest is a hash of the extension's transitive .bzl files.
	BzlTransitiveDigest string `json:"bzlTransitiveDigest,omitempty"`

	// UsagesDigest is a hash of how the extension is used.
	UsagesDigest string `json:"usagesDigest,omitempty"`

	// RecordedInputs lists files/repos read during evaluation.
	RecordedInputs []string `json:"recordedInputs,omitempty"`

	// GeneratedRepoSpecs contains the repositories generated by the extension.
	GeneratedRepoSpecs map[string]RepoSpec `json:"generatedRepoSpecs,omitempty"`

	// RecordedRepoMappingEntries contains repo mapping entries used.
	RecordedRepoMappingEntries []string `json:"recordedRepoMappingEntries,omitempty"`
}

// RepoSpec describes a repository generated by a module extension.
type RepoSpec struct {
	// RepoRuleID identifies the repo rule used (e.g., "@@bazel_tools//tools/build_defs/repo:http.bzl%http_archive").
	RepoRuleID string `json:"repoRuleId"`

	// Attributes are the arguments passed to the repo rule.
	Attributes map[string]any `json:"attributes"`
}

// ModuleKey represents a module name and version pair.
type ModuleKey struct {
	Name    string
	Version string
}

// String returns the string representation "name@version" or "name@_" for overrides.
func (k ModuleKey) String() string {
	if k.Version == "" {
		return k.Name + "@_"
	}
	return k.Name + "@" + k.Version
}

// MarshalText implements encoding.TextMarshaler for use as map keys.
func (k ModuleKey) MarshalText() ([]byte, error) {
	return []byte(k.String()), nil
}

// UnmarshalText implements encoding.TextUnmarshaler for use as map keys.
func (k *ModuleKey) UnmarshalText(text []byte) error {
	s := string(text)
	for i := len(s) - 1; i >= 0; i-- {
		if s[i] == '@' {
			k.Name = s[:i]
			k.Version = s[i+1:]
			if k.Version == "_" {
				k.Version = ""
			}
			return nil
		}
	}
	k.Name = s
	k.Version = ""
	return nil
}

// New creates a new empty lockfile with the current version.
func New() *Lockfile {
	return &Lockfile{
		Version:                CurrentVersion,
		RegistryFileHashes:     make(map[string]string),
		SelectedYankedVersions: make(map[string]string),
		ModuleExtensions:       make(map[string]ModuleExtensionEntry),
		Facts:                  make(map[string]json.RawMessage),
	}
}

// SetRegistryHash records the hash for a registry file URL.
func (l *Lockfile) SetRegistryHash(url, hash string) {
	if l.RegistryFileHashes == nil {
		l.RegistryFileHashes = make(map[string]string)
	}
	l.RegistryFileHashes[url] = hash
}

// GetRegistryHash returns the recorded hash for a URL, or empty if not found.
func (l *Lockfile) GetRegistryHash(url string) string {
	return l.RegistryFileHashes[url]
}

// HasRegistryHash returns true if a hash is recorded for the URL.
func (l *Lockfile) HasRegistryHash(url string) bool {
	_, ok := l.RegistryFileHashes[url]
	return ok
}

// AllowYankedVersion records that a yanked version was explicitly allowed.
func (l *Lockfile) AllowYankedVersion(key ModuleKey, reason string) {
	if l.SelectedYankedVersions == nil {
		l.SelectedYankedVersions = make(map[string]string)
	}
	l.SelectedYankedVersions[key.String()] = reason
}

// IsYankedVersionAllowed returns true if the yanked version is explicitly allowed.
func (l *Lockfile) IsYankedVersionAllowed(key ModuleKey) bool {
	_, ok := l.SelectedYankedVersions[key.String()]
	return ok
}

// GetYankedVersionReason returns the reason a yanked version was allowed.
func (l *Lockfile) GetYankedVersionReason(key ModuleKey) string {
	return l.SelectedYankedVersions[key.String()]
}

// RegistryURLs returns all registry URLs that have recorded hashes.
func (l *Lockfile) RegistryURLs() []string {
	urls := make([]string, 0, len(l.RegistryFileHashes))
	for url := range l.RegistryFileHashes {
		urls = append(urls, url)
	}
	return urls
}

// ExtensionIDs returns all module extension identifiers in the lockfile.
func (l *Lockfile) ExtensionIDs() []string {
	ids := make([]string, 0, len(l.ModuleExtensions))
	for id := range l.ModuleExtensions {
		ids = append(ids, id)
	}
	return ids
}

// IsCompatible returns true if the lockfile version is compatible with this package.
// Note: Bazel itself requires EXACT version matching. This method is more lenient
// for reading/parsing purposes. Use IsExactMatch() for Bazel-compatible behavior.
func (l *Lockfile) IsCompatible() bool {
	// Allow reading lockfiles from Bazel 7.2.0+ (version 11+)
	// These share a similar structure with incremental lockfile format.
	return l.Version >= 11 && l.Version <= CurrentVersion+4
}

// IsExactMatch returns true if the lockfile version exactly matches CurrentVersion.
// This is what Bazel requires for lockfile compatibility.
func (l *Lockfile) IsExactMatch() bool {
	return l.Version == CurrentVersion
}

// RequiredBazelVersion returns the Bazel version(s) that use this lockfile version.
// Returns nil if the version is unknown.
func (l *Lockfile) RequiredBazelVersion() []BazelVersion {
	return BazelVersionsForLockfile(l.Version)
}
